Phân tích và thiết kế PM (1) - Tổng quan
1. Tổng quan
1.1 Tham khảo quy trình để làm ra một sản phẩm phần mềm
Phần này lược thuật lại buổi nói chuyện về Product Management for Managers, của tác giả Hieu Nguyen.
Theo tác giả, để làm ra một sản phẩm (phần mềm) hiệu quả, có xác suất thành công cao thì cần làm theo các bước trong Tháp quản lý sản phẩm (Product Management Tower). Tác giả minh họa bằng sản phẩm Airbnb (giả định).
Tháp quản lý sản phẩm gồm các bước sau:
 

Giải thích từng bước:
– [1] Target Market: thị trường mục tiêu mà chúng ta muốn hướng đến, nó dựa trên hai yếu tố là thị trường mà chúng ta am hiểu và độ lớn của nó. Vì hiểu thị trường, nên biết nó đang cần gì? Biết mình phải làm gì để đáp ứng nhu cầu của thị trường. Chúng ta cũng cần biết được độ lớn của thị trường để đảm bảo khả năng sinh lời của sản phẩm. Ví dụ: Airbnb có thế mạnh về du lịch, chứ không có thế mạnh về giao vận (logistic) và ngân hàng (banking). Do vậy, nó đã chọn du lịch để tập trung vào.
– [2] Segmentation: lựa chọn phân khúc khách hàng. Chia thị trường thành các phân khúc khách hàng khác nhau. Ví dụ: trẻ em, giới trẻ, gia đình, thương nhân, nhà giàu. Sau đó loại đi các phân khúc mà chúng ta không muốn phục vụ hoặc không thể phục vụ (loại đi những nhóm khách hàng không có tiềm năng). Airbnb chọn 3 nhóm khách hàng để phục vụ là giới trẻ (young), gia đình (family) và thương nhân (business).
– [3] Target Customers: sau khi lựa chọn được phân khúc khách hàng, chúng ta sẽ có Tập khách hàng tiềm năng: giới trẻ (young people), gia đình (families) và thương nhân (business).
– [4] User Personas: từ Tập khách hàng tiềm năng, chúng ta sẽ đưa ra được bản mô tả về khách hàng hay Chân dung khách hàng (profile, user personas). Đây là bản mô tả chung về một nhóm người dùng mục tiêu của một sản phẩm. Tập trung vào hành vi và mục tiêu của khách hàng khi sử dụng sản phẩm của chúng ta.
– [5] Needs: thực hiện phỏng vấn, khảo sát, để biết được các nhu cầu của khách hàng mục tiêu (need). Ví dụ người đi du lịch sẽ cần một nơi để ở (place to stay), phương tiện đi lại (transportation), bảo hiểm (travel insurance), các đánh giá về địa điểm họ sẽ tới (attraction review), các hoạt động (activities), ăn (foods), hướng dẫn viên du lịch (tour guides), đặt vé máy bay (flight booking), đổi tiền (forex).
– [6] Underserved Needs (Pain Points): sắp xếp các nhu cầu của khách hàng mục tiêu, từ quan trọng nhất đến ít quan trọng hơn, tìm ra được những nhu cầu khách hàng cần, nhưng chưa được phục vụ tốt bởi các dịch vụ đang có (pain points). Cách làm: loại đi các dịch vụ đã được phục vụ tốt hoặc các dịch vụ mà không phải là thế mạnh của chúng ta. Airbnb tập trung vào chỗ ở, các hoạt động, ăn, và hướng dẫn viên du lịch.
– [7] Product Market-Fit: sản phẩm thị trường đang cần, và người dùng cảm thấy hài lòng khi sử dụng sản phẩm đó.
– [8] Value Proposition: đưa ra các dịch vụ mà khách hàng cần, nhằm giúp họ được sử dụng các dịch vụ tốt hơn những cái đang có. Ví dụ: Airbnb tập trung vào chỗ ở (accomodation) và trải nghiệm du lịch (experiences).
– [9] Product Feature Set: cần sản phẩm gì? sản phẩm gồm các chức năng gì? để đáp ứng nhu cầu của khách hàng. Ví dụ: dịch vụ chỗ ở cho gia đình, cho người đi công tác; danh sách các địa danh du lịch nổi tiếng (list), tìm kiếm trong du lịch (search), thanh toán (payment), đặt chỗ (booking).
– [10] User Experience: thiết kế trải nghiệm người dùng, không chỉ tập trung và trải nghiệm người dùng, mà quan trọng hơn là đáp ứng được nhu cầu của người dùng.
– [11] User Interface: thiết kế giao diện ứng dụng.
– [12] Front-end: làm phần front-end của ứng dụng.
– [13] Back-end: làm phần back-end của ứng dụng
Như vậy, để làm ra một sản phẩm phần mềm, chúng ta cần trải qua rất nhiều công đoạn. Mỗi công đoạn yêu cầu những kỹ năng và kinh nghiệm khác nhau; mỗi công đoạn thuộc về một bộ phận cụ thể trong một công ty.
Bạn cần có tư duy tổng thể, để biết được bức tranh lớn của công việc chúng ta đang làm, biết được mối liên hệ, vai trò của mỗi công đoạn.
Với vai trò là nhà phát triển phần mềm (software developer), tùy khả năng, chúng ta sẽ tập trung vào các công đoạn như lập trình back-end, front-end, thiết kế giao diện, thiết kế trải nghiệm, phân tích yêu cầu, xác định yêu cầu.
1.2 Các giai đoạn của một dự án phần mềm
Ở phần trước (Tham khảo quy trình để làm ra một sản phẩm phần mềm), bạn đã được tiếp cận quá trình làm ra một sản phẩm phần mềm dưới góc nhìn của một người tạo ra sản phẩm, của một người khởi nghiệp. Người này đòi hỏi có tố chất sáng tạo, óc quan sát tốt, nhìn ra được nhu cầu của thị trường.
Phần này cho bạn một cách nhìn khác về các bước để tạo ra một sản phẩm phần mềm. Nó là góc nhìn của một người thuần về kỹ thuật, chủ yếu tập trung vào các công đoạn để tạo ra một sản phẩm phần mềm. Nó gồm một số bước cụ thể hơn, chi tiết hơn.
Bảng sau là các bước cơ bản, cần thực hiện để có một sản phẩm phần mềm hoàn thiện.
 


Giải thích chi tiết từng bước, để bạn dễ hình dung:
[Bước 1] Phân tích yêu cầu khách hàng
Đây là bước đầu tiên và quan trọng nhất. Nhóm phát triển sẽ gặp gỡ khách hàng để hiểu rõ họ cần gì, vấn đề mà họ đang gặp phải là gì. Mục tiêu là nắm bắt chính xác các yêu cầu về nghiệp vụ, tính năng, và kỳ vọng của người dùng cuối. Nếu thiếu bước này, sản phẩm có thể không đáp ứng được nhu cầu thực tế.
Ví dụ: Một công ty muốn tạo ra một ứng dụng quản lý bán hàng. Họ cần ứng dụng đó có thể theo dõi doanh số, quản lý kho hàng và in hóa đơn.
[Bước 2] Phân tích chức năng hệ thống
Sau khi có yêu cầu từ khách hàng, đội ngũ phân tích sẽ chuyển đổi các yêu cầu đó thành các chức năng cụ thể của phần mềm. Bước này liên quan đến việc xác định các mô-đun (module), tính năng chính và cách chúng hoạt động.
Ví dụ: Từ yêu cầu của công ty bán hàng, các chức năng được xác định là:
- Mô-đun "Quản lý kho": Thêm sản phẩm, xóa sản phẩm, cập nhật số lượng tồn kho.
- Mô-đun "Bán hàng": Tạo hóa đơn, tính tiền, áp dụng khuyến mãi.
- Mô-đun "Báo cáo": Thống kê doanh số theo ngày, tháng, năm.
[Bước 3] Thiết kế cơ sở dữ liệu
Đây là việc tạo ra cấu trúc để lưu trữ thông tin của phần mềm. Một cơ sở dữ liệu tốt sẽ giúp phần mềm hoạt động hiệu quả, ổn định và dễ dàng truy cập dữ liệu.
Ví dụ: Thiết kế các bảng (table) để lưu thông tin về:
- Sản phẩm: Tên sản phẩm, mã sản phẩm, giá bán, số lượng.
- Hóa đơn: Mã hóa đơn, ngày bán, tổng tiền. 
- Khách hàng: Tên, số điện thoại, địa chỉ.
[Bước 4] Thiết kế giao diện
Đây là bước tạo ra giao diện mà người dùng sẽ tương tác. Giao diện (UI) cần trực quan, dễ sử dụng và thể hiện được tính độc đáo của sản phẩm. Bước này cũng bao gồm việc thiết kế trải nghiệm người dùng (UX) để đảm bảo người dùng có thể thực hiện các tác vụ một cách dễ dàng và hiệu quả.
Ví dụ:
- Thiết kế giao diện mua hàng: Giao diện cần có các nút rõ ràng như "Thêm vào giỏ hàng", "Thanh toán", và các hình ảnh sản phẩm đẹp mắt.
- Thiết kế báo cáo: Biểu đồ hiển thị doanh thu phải dễ đọc, các số liệu được trình bày khoa học.
[Bước 5] Thiết kế kiến trúc ứng dụng
Kiến trúc ứng dụng là "bộ khung" của phần mềm, quyết định cách các thành phần (máy chủ, cơ sở dữ liệu, giao diện) liên kết và giao tiếp với nhau. Một kiến trúc tốt giúp phần mềm dễ dàng mở rộng, bảo trì và hoạt động ổn định khi có nhiều người dùng.
Ví dụ: Lựa chọn kiến trúc ba tầng (3-tier architecture), trong đó có tầng giao diện người dùng (Front-end), tầng xử lý nghiệp vụ (Back-end) và tầng cơ sở dữ liệu (Database).
[Bước 6] Cài đặt (Lập trình)
Đây là giai đoạn viết mã (coding) để biến các thiết kế thành một sản phẩm phần mềm thực tế. Lập trình viên sẽ sử dụng các ngôn ngữ lập trình (như Python, Java, JavaScript, C#) để xây dựng các chức năng đã được phân tích và thiết kế.
Ví dụ: Lập trình viên viết mã để:
- Tạo chức năng "Đăng nhập" để người dùng truy cập hệ thống.
- Kết nối với cơ sở dữ liệu để lấy thông tin sản phẩm.
- Lập trình tính toán tổng tiền khi tạo hóa đơn.
[Bước 7] Kiểm tra và sửa lỗi
Sau khi các chức năng hoặc phần mềm được viết xong, đội ngũ kiểm thử (Tester) sẽ thực hiện kiểm tra toàn diện để tìm ra các lỗi (bugs) và đảm bảo các chức năng và phần mềm hoạt động đúng như mong đợi. Bước này bao gồm kiểm tra chức năng, hiệu năng, bảo mật và khả năng tương thích.
Ví dụ: Kiểm tra xem nút "Thanh toán" có hoạt động đúng không, ứng dụng có bị chậm khi có nhiều người truy cập không, hoặc có lỗ hổng bảo mật nào không.
[Bước 8] Viết tài liệu hướng dẫn
Đây là công đoạn tạo các tài liệu cần thiết cho người dùng và cho các thành viên trong đội ngũ kỹ thuật. Tài liệu giúp người dùng biết cách sử dụng sản phẩm và giúp các lập trình viên khác dễ dàng bảo trì, phát triển thêm các tính năng mới sau này.
Ví dụ:
- Tài liệu hướng dẫn sử dụng: Hướng dẫn từng bước cách sử dụng các tính năng chính cho người dùng cuối.
- Tài liệu kỹ thuật: Mô tả cấu trúc mã nguồn, cách triển khai hệ thống cho lập trình viên.
[Bước 9] Vận hành
Sau khi phần mềm đã hoàn thiện và được kiểm thử, nó sẽ được triển khai (deploy) và đưa vào hoạt động chính thức. Đội ngũ kỹ thuật sẽ đảm bảo phần mềm hoạt động ổn định trên máy chủ và sẵn sàng phục vụ người dùng.
[Bước 10] Quản trị, bảo trì và SEO
Đây là giai đoạn tiếp theo của quá trình vận hành, đảm bảo phần mềm luôn hoạt động tốt và được cập nhật.
- Quản trị và bảo trì: Theo dõi hiệu suất, khắc phục các sự cố phát sinh, cập nhật phiên bản mới, và vá lỗi bảo mật.
- SEO (Search Engine Optimization): Nếu là một ứng dụng web, bước này giúp tối ưu hóa để phần mềm dễ dàng được tìm thấy trên các công cụ tìm kiếm như Google.
Phân tích và thiết kế PM (2) - Các mô hình phát triển phần mềm
Bài trước: Phân tích và thiết kế PM (1) - Tổng quan
-----
2. Các mô hình phát triển phần mềm
Ở phần trước, bạn đã biết được các bước cơ bản để tạo ra một sản phẩm phần mềm. Với góc nhìn của một nhà khởi nghiệp (gồm 13 bước), và của một nhà phát triển phần mềm (gồm 10 bước).
Tuy nhiên, trong thực tế, chúng ta không nhất thiết phải thực hiện tuần tự từng bước, theo nghĩa: bước 1 phải xong thì mới chuyển qua bước 2; khi đã làm bước 2 rồi thì không được quay lại bước 1. Trong phần này, chúng ta cùng xem qua các mô hình phát triển phần mềm, để chọn một mô hình phù hợp với dự án thực tế.
2.1 Một số mô hình phát triển phần mềm
Ví dụ, một số mô hình phát triển phần mềm:
- Mô hình thác nước.
- Mô hình chữ V.
- Mô hình xoắn ốc. 
- Mô hình hợp nhất.
- Mô hình tiếp cận lặp.
- Mô hình nguyên mẫu.
- Mô hình Scrum.
- Mô hình Kanban.
- Mô hình XP.
Dưới đây là mô tả ngắn gọn về đặc điểm và tình huống áp dụng của mỗi mô hình phát triển phần mềm:
[1] Mô hình thác nước (Waterfall Model)
 
- Đặc điểm: Đây là mô hình tuần tự, các giai đoạn phát triển diễn ra theo một trình tự tuyến tính, từ trên xuống dưới như một dòng thác. Mỗi giai đoạn phải được hoàn thành trước khi chuyển sang giai đoạn tiếp theo và không có sự quay lại.
- Áp dụng: Phù hợp với các dự án có yêu cầu ổn định, đã được xác định rõ ràng ngay từ đầu và không có khả năng thay đổi. Ví dụ: các dự án phát triển phần mềm nhúng hoặc các dự án quốc phòng.
[2] Mô hình chữ V (V-Model)
 

- Đặc điểm: Là một biến thể của mô hình thác nước, mô hình chữ V nhấn mạnh việc kiểm thử được thực hiện song song với các giai đoạn phát triển. Mỗi giai đoạn phát triển sẽ tương ứng với một giai đoạn kiểm thử cụ thể.
- Áp dụng: Phù hợp cho các dự án yêu cầu độ tin cậy cao, ví dụ như các hệ thống y tế hoặc các hệ thống kiểm soát công nghiệp.
[3] Mô hình xoắn ốc (Spiral Model)
 
- Đặc điểm: Là mô hình lặp đi lặp lại, tập trung vào việc quản lý rủi ro. Mỗi vòng xoắn tượng trưng cho một giai đoạn phát triển, bắt đầu bằng việc lập kế hoạch (plan), sau đó là phân tích rủi ro (risk analysis), phát triển (engineering), và đánh giá (evaluate).
- Áp dụng: Thích hợp cho các dự án lớn, phức tạp và có nhiều rủi ro. Mô hình này cho phép giảm thiểu rủi ro một cách hiệu quả.
[4] Mô hình hợp nhất (RUP - Rational Unified Process)
 
- Đặc điểm: RUP là một quy trình phát triển lặp đi lặp lại và hướng đối tượng. Nó chia dự án thành bốn giai đoạn chính: Khởi đầu (Inception), Cụ thể hóa (Elaboration), Xây dựng (Construction) và Chuyển giao (Transition). RUP nhấn mạnh việc lập tài liệu và tuân thủ quy trình.
- Áp dụng: Phù hợp với các dự án lớn, phức tạp, đặc biệt là các dự án phát triển phần mềm hướng đối tượng.
[5] Mô hình tiếp cận lặp (Iterative Model)
 
- Đặc điểm: Mô hình này chia dự án thành nhiều lần lặp (iteration) nhỏ. Mỗi lần lặp sẽ tạo ra một phiên bản sản phẩm có thể hoạt động được, bổ sung thêm tính năng qua mỗi lần lặp.
- Áp dụng: Dành cho các dự án mà yêu cầu không rõ ràng ngay từ đầu, hoặc khi cần phát hành sản phẩm sớm để lấy ý kiến phản hồi từ người dùng.
[6] Mô hình nguyên mẫu (Prototyping Model)
 
- Đặc điểm: Tạo ra một phiên bản thử nghiệm (prototype) của sản phẩm để người dùng đánh giá và đưa ra phản hồi. Prototype này không có đầy đủ chức năng nhưng giúp khách hàng hình dung sản phẩm cuối cùng. Sau khi có phản hồi, phiên bản cuối cùng sẽ được xây dựng dựa trên đó.
- Áp dụng: Thích hợp cho các dự án mà yêu cầu của người dùng chưa được xác định rõ ràng, hoặc khi cần một bản demo nhanh để thuyết phục khách hàng.
[7] Mô hình Scrum
 


- Đặc điểm: Là một trong những mô hình Agile phổ biến nhất. Scrum dựa trên việc chia dự án thành các chu kỳ phát triển ngắn (thường 1-4 tuần) gọi là Sprint. Trong mỗi Sprint, đội nhóm sẽ hoàn thành một tập hợp các tính năng được ưu tiên.
- Áp dụng: Phù hợp với các dự án có yêu cầu thường xuyên thay đổi và cần sự linh hoạt, nơi mà sự hợp tác chặt chẽ giữa các thành viên và với khách hàng là yếu tố then chốt.
[8] Mô hình Kanban
 
- Đặc điểm: Cũng là một mô hình Agile, Kanban tập trung vào việc quản lý và tối ưu hóa quy trình làm việc. Nó sử dụng một bảng trực quan (bảng Kanban) để theo dõi tiến độ công việc, giới hạn số lượng công việc đang thực hiện ở mỗi giai đoạn để tránh tắc nghẽn.
- Áp dụng: Phù hợp cho các dự án bảo trì, hỗ trợ hoặc các dự án có luồng công việc liên tục, không theo chu kỳ cố định.
[9] Mô hình XP (Extreme Programming)
 
- Đặc điểm: Là một mô hình Agile chú trọng vào sự đơn giản, giao tiếp, phản hồi và sự can đảm. XP bao gồm các thực hành như lập trình theo cặp (pair programming), thiết kế đơn giản và tích hợp liên tục.
- Áp dụng: Lý tưởng cho các dự án nhỏ, yêu cầu có sự thay đổi nhanh chóng và cần sự giao tiếp liên tục trong đội ngũ.
Phân tích và thiết kế PM (3) - Yêu cầu
Bài trước: Phân tích và thiết kế PM (2) - Các mô hình phát triển phần mềm
-----
3. Yêu cầu
3.1 Yêu cầu là gì
Trong phát triển phần mềm, yêu cầu (requirements) là những mô tả về các điều kiện, khả năng, và tính năng mà một hệ thống phần mềm phải có để đáp ứng nhu cầu của người dùng hoặc các bên liên quan. Nói một cách đơn giản, yêu cầu là cầu nối giữa mong muốn của khách hàng và sản phẩm cuối cùng.
Yêu cầu là nền tảng cho toàn bộ quá trình phát triển phần mềm. Nếu không có các yêu cầu rõ ràng và chính xác, dự án sẽ gặp rủi ro lớn vì nhóm phát triển có thể xây dựng một sản phẩm không đáp ứng được mục đích ban đầu, dẫn đến lãng phí thời gian và nguồn lực.
3.2 Các loại yêu cầu
Trong phát triển phần mềm, chúng ta quan tâm tới 3 loại yêu cầu sau:
- Yêu cầu người dùng (user requirements).
- Yêu cầu nghiệp vụ (domain requirements).
- Phi yêu cầu (non-requirements).
Chúng ta cùng tìm hiểu chi tiết hơn về mỗi loại yêu cầu:
[1] Yêu cầu người dùng
Yêu cầu người dùng (user requirement) là những nhu cầu, mong đợi, và kỳ vọng của người dùng cuối về một sản phẩm, hệ thống, hoặc dịch vụ. Nó mô tả những gì người dùng mong đợi hệ thống thực hiện để giải quyết vấn đề của họ.
Yêu cầu người dùng chia thành 2 loại: chức năng (tính năng của hệ thống) và phi chức năng (tốc độ, hiệu suất, tin cậy).
Yêu cầu được viết bằng ngôn ngữ tự nhiên, dễ hiểu, không mang tính kỹ thuật. Yêu cầu người dùng thường được thu thập thông qua phỏng vấn, khảo sát, và các buổi họp với khách hàng hoặc người dùng cuối.
Yêu cầu này thường được ghi lại trong một tài liệu gọi là Tài liệu đặc tả yêu cầu người dùng (User Requirement Specification - URS) để làm cơ sở cho việc thiết kế và phát triển sản phẩm. 
Mục đích của yêu cầu người dùng
- Định hướng phát triển: Giúp đội ngũ phát triển và kỹ sư hiểu rõ nhu cầu của người dùng để xây dựng sản phẩm đúng mong muốn.
- Đảm bảo sự hài lòng: Sản phẩm cuối cùng sẽ đáp ứng các kỳ vọng của người dùng, mang lại trải nghiệm tốt và sự hài lòng.
- Quản lý dự án: Là cơ sở để lập kế hoạch, ước tính chi phí, kiểm soát dự án và đánh giá thành công. 
Đặc điểm của yêu cầu người dùng
- Từ góc độ người dùng: Tài liệu URS được viết theo góc nhìn của người dùng cuối, không quá kỹ thuật hay phức tạp, và để người dùng có kiến thức chung về hệ thống có thể hiểu được. 
- Chức năng và phi chức năng: Bao gồm các tính năng mà hệ thống cần có (chức năng) và các yếu tố khác như hiệu suất, tốc độ, độ tin cậy (phi chức năng).
- Làm cơ sở cho tài liệu kỹ thuật: Là nền tảng cho các tài liệu đặc tả kỹ thuật do đội ngũ phát triển tạo ra, quy định cách thức đáp ứng yêu cầu của người dùng. 
Yêu cầu chức năng
Yêu cầu chức năng là các tính năng cụ thể mà một hệ thống phải thực hiện để đáp ứng nhu cầu của người dùng.
Ví dụ, yêu cầu tính năng của hệ thống Bán sách trực tuyến, gồm:
1. Yêu cầu liên quan đến người dùng
Các yêu cầu này tập trung vào việc quản lý thông tin và tương tác của người dùng với hệ thống.
(FR là viết tắt của Functional Requirements: yêu cầu chức năng)
- Đăng ký và đăng nhập:
+ FR-1.1: Hệ thống phải cho phép người dùng mới đăng ký tài khoản bằng cách cung cấp email, tên đầy đủ và mật khẩu.
+ FR-1.2: Hệ thống phải xác thực thông tin đăng nhập của người dùng đã có tài khoản.
+ FR-1.3: Hệ thống phải cung cấp tính năng "Quên mật khẩu", cho phép người dùng đặt lại mật khẩu qua email.
- Quản lý tài khoản cá nhân:
+ FR-1.4: Người dùng phải có khả năng cập nhật thông tin cá nhân của họ, bao gồm tên, địa chỉ, số điện thoại.
+ FR-1.5: Người dùng phải có thể xem lịch sử mua hàng của họ, bao gồm các đơn hàng đã đặt, trạng thái đơn hàng và chi tiết các sản phẩm đã mua.
2. Yêu cầu liên quan đến sản phẩm và tìm kiếm
Những yêu cầu này mô tả cách người dùng tương tác với danh mục sản phẩm.
- Tìm kiếm và lọc sản phẩm:
+ FR-2.1: Hệ thống phải cho phép người dùng tìm kiếm sách theo tiêu đề, tác giả, hoặc nhà xuất bản.
+ FR-2.2: Người dùng phải có khả năng lọc kết quả tìm kiếm theo nhiều tiêu chí như thể loại (tiểu thuyết, kinh tế, khoa học), giá cả, hoặc đánh giá của người dùng.
- Hiển thị thông tin sản phẩm:
+ FR-2.3: Hệ thống phải hiển thị một trang chi tiết cho mỗi cuốn sách, bao gồm hình ảnh bìa, mô tả, giá, tác giả, và các thông số kỹ thuật khác (số trang, năm xuất bản).
+ FR-2.4: Trang chi tiết sản phẩm phải hiển thị các đánh giá và nhận xét từ những người dùng khác.
3. Yêu cầu liên quan đến giỏ hàng và thanh toán
Các yêu cầu này mô tả quy trình mua hàng, từ khi thêm sản phẩm vào giỏ đến khi hoàn tất thanh toán.
- Quản lý giỏ hàng:
+ FR-3.1: Người dùng phải có khả năng thêm một hoặc nhiều cuốn sách vào giỏ hàng.
+ FR-3.2: Người dùng có thể chỉnh sửa số lượng sách trong giỏ hàng hoặc xóa sách ra khỏi giỏ.
+ FR-3.3: Giỏ hàng phải tự động cập nhật tổng giá trị đơn hàng khi có thay đổi về số lượng hoặc sản phẩm.
- Thanh toán và đặt hàng:
+ FR-3.4: Hệ thống phải cho phép người dùng lựa chọn phương thức thanh toán.
+ FR-3.5: Hệ thống phải gửi một email xác nhận đơn hàng tới người dùng sau khi thanh toán thành công, kèm theo chi tiết đơn hàng và mã theo dõi.
4. Yêu cầu liên quan đến đánh giá và nhận xét
- FR-4.1: Người dùng đã mua một cuốn sách phải có khả năng viết đánh giá và xếp hạng (ví dụ, từ 1 đến 5 sao) cho cuốn sách đó.
- FR-4.2: Các đánh giá phải được hiển thị trên trang chi tiết sản phẩm và được sắp xếp theo thời gian hoặc độ hữu ích.
Yêu cầu phi chức năng
Yêu cầu phi chức năng không tập trung vào các tính năng cụ thể, mà quan tâm tới chất lượng của hệ thống, như tốc độ, bảo mật, khả năng mở rộng, độ tin cậy.
Ví dụ:
Các yêu cầu phi chức năng của hệ thống Bán sách trực tuyến:
1. Hiệu suất (Performance)
- Tốc độ tải trang: Trang chủ và trang danh sách sản phẩm phải tải hoàn toàn trong vòng dưới 3 giây, ngay cả trong giờ cao điểm.
- Thời gian phản hồi: Hệ thống phải xử lý yêu cầu tìm kiếm và lọc sản phẩm trong vòng chưa đầy 2 giây.
- Khả năng chịu tải: Hệ thống phải có khả năng xử lý đồng thời 5.000 người dùng mà không bị chậm hoặc ngừng hoạt động.
2. Khả năng sử dụng (Usability)
- Giao diện trực quan: Giao diện người dùng phải dễ hiểu, các nút và liên kết phải rõ ràng để người dùng có thể dễ dàng tìm kiếm, thêm sách vào giỏ hàng và thanh toán mà không cần hướng dẫn.
- Tương thích đa nền tảng: Website phải hiển thị và hoạt động tốt trên các trình duyệt phổ biến như Chrome, Firefox và trên các thiết bị di động (điện thoại, máy tính bảng) với các kích thước màn hình khác nhau.
- Trợ giúp và hỗ trợ: Hệ thống nên có các mục FAQ (câu hỏi thường gặp) hoặc chatbot để trả lời các câu hỏi cơ bản của người dùng.
3. Bảo mật (Security)
- Bảo vệ dữ liệu người dùng: Tất cả thông tin cá nhân của người dùng, bao gồm tên, địa chỉ, và mật khẩu, phải được mã hóa và lưu trữ an toàn.
- Bảo mật thanh toán: Toàn bộ giao dịch thanh toán phải tuân thủ các tiêu chuẩn bảo mật quốc tế (ví dụ: PCI DSS) để đảm bảo thông tin thẻ tín dụng của người dùng được bảo vệ.
- Chống tấn công: Hệ thống phải có cơ chế bảo vệ chống lại các cuộc tấn công mạng phổ biến như SQL Injection và XSS (Cross-Site Scripting).
4. Độ tin cậy (Reliability)
- Thời gian hoạt động (Uptime): Hệ thống phải đảm bảo thời gian hoạt động ít nhất 99.9% mỗi tháng, tức là không được ngừng hoạt động quá 44 phút.
- Sao lưu dữ liệu: Dữ liệu người dùng và đơn hàng phải được sao lưu tự động hàng ngày để có thể khôi phục lại trong trường hợp xảy ra sự cố.
5. Khả năng mở rộng (Scalability)
- Mở rộng kho sách: Hệ thống phải được thiết kế để dễ dàng thêm hàng nghìn đầu sách mới mà không ảnh hưởng đến hiệu suất.
- Hỗ trợ tính năng mới: Kiến trúc hệ thống phải cho phép tích hợp các tính năng bổ sung trong tương lai, chẳng hạn như hệ thống tích điểm thưởng cho khách hàng hoặc chương trình giới thiệu sản phẩm.
[2] Yêu cầu nghiệp vụ
Yêu cầu nghiệp vụ (domain requirements) là những quy tắc, chính sách, và nguyên tắc kinh doanh mà một hệ thống phần mềm phải tuân thủ. Chúng không phải là các chức năng cụ thể mà người dùng tương tác, mà là những ràng buộc nền tảng quyết định cách hệ thống hoạt động trong một lĩnh vực cụ thể (ví dụ: bán lẻ, tài chính, y tế).
Nói một cách đơn giản, yêu cầu nghiệp vụ trả lời câu hỏi: "Doanh nghiệp/tổ chức của tôi hoạt động như thế nào, và phần mềm này phải tuân theo những quy tắc nào?"
Ví dụ:
Trong một ứng dụng bán sách, yêu cầu nghiệp vụ có thể là: 
Quản lý kho sách:
- Hệ thống phải có khả năng thêm mới, cập nhật, và xóa thông tin sách (tên sách, tác giả, nhà xuất bản, giá, số lượng tồn kho).
- Hệ thống cần tự động trừ số lượng sách khi có đơn hàng được đặt thành công.
- Hệ thống phải thông báo cho người quản lý khi số lượng một đầu sách xuống dưới mức cảnh báo để nhập hàng.
Quản lý đơn hàng:
- Khách hàng phải có khả năng tạo đơn hàng mới với nhiều đầu sách khác nhau.
- Hệ thống cần tính toán tổng giá tiền cho đơn hàng, bao gồm cả thuế và phí vận chuyển.
- Hệ thống phải theo dõi trạng thái của đơn hàng (đang xử lý, đã giao, đã thanh toán, đã hủy) và thông báo cho khách hàng.
Quản lý tài khoản khách hàng:
- Khách hàng phải có khả năng đăng ký tài khoản, đăng nhập, và quản lý thông tin cá nhân (địa chỉ, số điện thoại).
- Hệ thống cần lưu trữ lịch sử đơn hàng của từng khách hàng.
[4] Phi yêu cầu
Phi yêu cầu (non-requirement) là một khái niệm hoặc giả định được xác định trong giai đoạn phân tích dự án, nhưng không phải là một yêu cầu chức năng hay phi chức năng mà hệ thống cần phải thực hiện.
Các "phi yêu cầu" thường là những điều kiện không thể đáp ứng, nằm ngoài phạm vi của dự án, hoặc những giả định cơ bản mà nhóm phát triển cần biết để tránh hiểu lầm. Chúng đóng vai trò làm rõ ranh giới của dự án và giúp tránh lãng phí tài nguyên vào những việc không cần thiết.
Ví dụ về phi yêu cầu cho hệ thống Bán sách trực tuyến
- Không hỗ trợ hình thức thanh toán bằng tiền mặt: Hệ thống sẽ chỉ xử lý các giao dịch thanh toán trực tuyến qua thẻ tín dụng, ví điện tử hoặc chuyển khoản ngân hàng. Việc giao hàng và thu tiền mặt không thuộc phạm vi của dự án này.
- Không bao gồm chức năng chatbot tích hợp AI: Hệ thống này sẽ chỉ sử dụng các câu hỏi thường gặp (FAQ) và form liên hệ để hỗ trợ khách hàng, thay vì tích hợp một chatbot phức tạp.
- Không xử lý việc vận chuyển sản phẩm: Hệ thống sẽ chỉ tạo ra đơn hàng và chuyển thông tin cho một đối tác vận chuyển bên thứ ba. Trách nhiệm theo dõi, giao hàng, và xử lý các vấn đề phát sinh trong quá trình vận chuyển sẽ do đối tác đó đảm nhận, nằm ngoài phạm vi phát triển của phần mềm.
- Không hỗ trợ nhiều ngôn ngữ: Hệ thống sẽ chỉ được phát triển với ngôn ngữ tiếng Việt.
Những ví dụ trên giúp làm rõ những gì dự án sẽ không làm, từ đó giúp nhóm phát triển tập trung vào các yêu cầu đã được xác định, tránh việc phát sinh công việc ngoài ý muốn.
Phân tích và thiết kế PM (4) - Tổng quan về thiết kế
Bài trước: Phân tích và thiết kế PM (3) - Yêu cầu
-----
4. Tổng quan về thiết kế
Ở các phần trước, chúng ta đã có kiến thức tổng quan về các công đoạn để có một phần mềm, đã tìm hiểu sơ qua một số mô hình phát triển phần mềm, đã biết được các loại yêu cầu của một phần mềm.
Ngoài ra, bạn cũng đã có thể viết được một Tài liệu đặc tả yêu cầu người dùng (URS).
Bước tiếp theo của quá trình làm ra một phần mềm là chuyển đổi từ URS thành các Bản thiết kế.
Trong phần này chúng ta sẽ cùng tìm hiểu một số nội dung liên quan đến Thiết kế phần mềm.
4.1 Các khái niệm và nguyên tắc cơ bản
Trước khi đi sâu vào chi tiết, bạn cần nắm vững các nguyên tắc nền tảng của thiết kế phần mềm:
- Kiến trúc phần mềm (software architecture): Đây là cấu trúc tổng thể của một hệ thống, bao gồm các thành phần, mối quan hệ giữa chúng và các nguyên tắc thiết kế. Hiểu kiến trúc giúp bạn hình dung được "bản đồ" tổng thể của dự án.
- Nguyên tắc thiết kế (design principles): Tìm hiểu các nguyên tắc như SOLID (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) để viết mã sạch, dễ bảo trì và mở rộng.
- Mô hình thiết kế (design patterns): Đây là các giải pháp đã được kiểm chứng cho những vấn đề thiết kế phổ biến. Học các mô hình như Singleton, Factory, Observer, MVC (Model-View-Controller) giúp bạn giải quyết các vấn đề lặp đi lặp lại một cách hiệu quả.
4.2 Các giai đoạn và tài liệu thiết kế
Thiết kế phần mềm thường được chia thành hai giai đoạn chính, mỗi giai đoạn tạo ra một tài liệu cụ thể.
- Thiết kế kiến trúc cấp cao (High-Level Design - HLD):
  + Mục đích: Mô tả tổng quan về kiến trúc của hệ thống, các thành phần chính và cách chúng tương tác.
  + Nội dung: Biểu đồ khối (block diagrams), mô tả các module và luồng dữ liệu chính.
- Thiết kế chi tiết (Low-Level Design - LLD):
  + Mục đích: Đi sâu vào chi tiết của từng module. Đây là "bản vẽ chi tiết" để lập trình viên có thể viết mã.
  + Nội dung: Biểu đồ lớp (class diagrams), biểu đồ trình tự (sequence diagrams), biểu đồ luồng hoạt động (activity diagrams) và mô tả chi tiết từng chức năng.
4.3 Các loại biểu đồ thiết kế phổ biến
Các biểu đồ là công cụ trực quan hóa giúp bạn thể hiện ý tưởng thiết kế một cách rõ ràng và dễ hiểu.
- Biểu đồ trường hợp sử dụng (use case diagram): Mô tả mối quan hệ giữa người dùng (Actor) và các chức năng (Use Case) của hệ thống. Đây là cầu nối trực tiếp từ URS sang thiết kế.
- Biểu đồ lớp (class diagram): Thể hiện cấu trúc tĩnh của hệ thống, bao gồm các lớp, thuộc tính, phương thức và mối quan hệ giữa chúng (kế thừa, kết hợp, phụ thuộc).
- Biểu đồ trình tự (sequence diagram): Minh họa sự tương tác giữa các đối tượng trong một chức năng cụ thể theo trình tự thời gian.
- Biểu đồ hoạt động (activity diagram): Mô tả luồng công việc hoặc các bước xử lý trong một chức năng hoặc một quy trình nghiệp vụ.
4.4 Các khía cạnh quan trọng khác
Để thiết kế một hệ thống hoàn chỉnh, bạn cũng cần chú ý đến các yếu tố này:
- Thiết kế giao diện người dùng (user interface - UI) & Trải nghiệm người dùng (user experience - UX): Dựa trên các yêu cầu chức năng, bạn cần thiết kế giao diện trực quan và dễ sử dụng.
- Thiết kế cơ sở dữ liệu (database design): Đây là việc xây dựng cấu trúc để lưu trữ dữ liệu của hệ thống. Bạn cần tìm hiểu về mô hình quan hệ, các dạng chuẩn hóa (normalization) và cách thiết kế bảng, khóa chính, khóa ngoại.
- Bảo mật trong thiết kế (security by design): Ngay từ giai đoạn thiết kế, bạn cần xây dựng các cơ chế để chống lại các cuộc tấn công và bảo vệ dữ liệu.
Việc học và nắm vững các chủ đề trên sẽ giúp bạn chuyển từ việc hiểu "cần làm gì" (từ URS) sang việc xác định "làm như thế nào" (thiết kế phần mềm), tạo ra nền tảng vững chắc cho quá trình lập trình và phát triển tiếp theo.
Phân tích và thiết kế PM (5) - Kiến trúc phần mềm
Bài trước: Phân tích và thiết kế PM (4) - Tổng quan về thiết kế
-----
5. Kiến trúc phần mềm
5.1 Kiến trúc phần mềm là gì?
Kiến trúc phần mềm là bản thiết kế tổng thể của một hệ thống, giúp chúng ta hiểu rõ các bộ phận cấu thành, cách chúng kết nối và các quy tắc chi phối toàn bộ cấu trúc. Nó giống như bản vẽ kỹ thuật của một tòa nhà lớn, như: tòa nhà có bao nhiêu tầng, vật liệu chính là gì, hệ thống điện nước chạy như thế nào; mô tả các bộ phận (móng, cột, tường, mái), cách chúng được liên kết (hệ thống ống nước, dây điện) và mục tiêu chất lượng (chịu được động đất, tiết kiệm năng lượng).
Kiến trúc phần mềm trả lời câu hỏi: "Chúng ta nên xây dựng hệ thống này như thế nào?" thay vì "Hệ thống này làm được gì?" (câu hỏi của URS).
Kiến trúc phần mềm mô tả ba yếu tố chính của một hệ thống:
- Cấu trúc (structure): Hệ thống được chia thành các thành phần (components) hoặc mô-đun nhỏ hơn (ví dụ: mô-đun quản lý người dùng, mô-đun xử lý thanh toán)
- Tương tác (interaction): Các thành phần kết nối và trao đổi dữ liệu với nhau bằng cách nào (ví dụ: dùng API)
- Yếu tố chất lượng (quality attributes / NFR-Non-Functional Requirements): Đây là các yêu cầu phi chức năng mà kiến trúc phải có. Ví dụ: tốc độ, bảo mật, khả năng mở rộng, độ tin cậy
Vai trò quan trọng của Kiến trúc phần mềm:
- Tính ổn định: Đảm bảo hệ thống vững chắc, không bị sụp đổ khi lượng người dùng tăng lên
- Tính dễ hiểu: Giúp các lập trình viên “mới” hoặc các nhóm khác nhau dễ dàng nắm bắt được cách hệ thống hoạt động, từ đó đẩy nhanh quá trình phát triển, nâng cấp và sửa lỗi
- Tính mở rộng: Cho phép thêm tính năng hoặc tăng khả năng chịu tải một cách dễ dàng mà không cần phải phát triển lại toàn bộ hệ thống
5.2 Một số mô hình Kiến trúc phần mềm phổ biến
Có nhiều mô hình Kiến trúc phần mềm khác nhau, mỗi mô hình phù hợp với những yêu cầu và quy mô dự án cụ thể.
Bảng sau tóm tắt một số mô hình Kiến trúc phần mềm phổ biến:
Mô hình	Mô tả tóm tắt
Kiến trúc nguyên khối (monolithic)	Toàn bộ hệ thống được xây dựng như một đơn vị duy nhất, tất cả các chức năng đều nằm chung một khối mã và chia sẻ một cơ sở dữ liệu. (Giống như một căn nhà nhỏ, mọi thứ đều nằm chung một không gian)
Kiến trúc N-tầng (N-tiers)	Phân chia hệ thống thành các lớp (tầng) riêng biệt (thường là 3 tầng: Giao diện người dùng, Logic nghiệp vụ, Truy cập dữ liệu). Mỗi tầng chỉ giao tiếp với tầng cạnh nó. (Giống như một tòa nhà có các tầng chức năng rõ ràng)
Kiến trúc vi dịch vụ (Microservices)
(kiến trúc phân tán)	Hệ thống được chia thành nhiều dịch vụ nhỏ độc lập (microservices), mỗi dịch vụ chạy tiến trình riêng, có thể có cơ sở dữ liệu riêng, và giao tiếp với nhau qua mạng (thường là API). (Giống như một khu phức hợp với nhiều tòa nhà chuyên biệt, kết nối bằng hệ thống đường xá riêng)
Chúng ta cùng tìm hiểu sơ lược 3 mô hình kiến trúc phần mềm ở trên.
5.3 Kiến trúc nguyên khối
Kiến trúc nguyên khối là mô hình truyền thống, trong đó toàn bộ ứng dụng được xây dựng và triển khai dưới dạng một khối duy nhất. Tất cả các thành phần của ứng dụng như giao diện người dùng, logic nghiệp vụ và truy cập dữ liệu đều được tích hợp chặt chẽ trong cùng một ứng dụng.
Xem hình minh họa:
 
Trong đó:
- Giao diện người dùng (user interface)
- Logic nghiệp vụ (business layer)
- Truy cập dữ liệu (data interface)
Xem hình ảnh này để bạn dễ tưởng tượng hơn về kiến trúc monolithic:
 
Ưu điểm:
- Quá trình phát triển, triển khai đơn giản: Do tất cả nằm trong một khối duy nhất, việc phát triển, thử nghiệm và triển khai sẽ đơn giản hơn.
- Hiệu suất cao: Do không có giao tiếp liên bộ phận, ứng dụng thường có hiệu suất cao hơn.
Nhược điểm:
- Khó bảo trì và mở rộng: Khi ứng dụng phát triển lớn hơn, việc bảo trì và thêm tính năng mới trở nên phức tạp
- Khả năng chịu lỗi kém: Một lỗi nhỏ có thể làm gián đoạn toàn bộ hệ thống
Khi nào thì nên sử dụng mô hình nguyên khối:
- Dự án nhỏ, cần triển khai nhanh
- Đội ngũ phát triển ít thành viên
- Tài nguyên, máy móc ít
- Việc giao tiếp giữa các thành phần của ứng dụng cần hiệu suất cao
Ví dụ về các ứng dụng theo kiến trúc nguyên khối:
- Hầu hết các ứng dụng desktop truyền thống đều được thiết kế theo kiểu kiến trúc nguyên khối. Kiến trúc nguyên khối rất phù hợp với môi trường desktop vì toàn bộ ứng dụng chạy cục bộ trên một máy tính duy nhất.
- Hệ quản trị nội dung (CMS) cũ (wordpress), ứng dụng thương mại điện tử nhỏ
5.4 Kiến trúc N-tầng
Mô hình N-tầng (N-tiers) phân chia ứng dụng thành các tầng độc lập, chạy trên các máy chủ hoặc dịch vụ khác nhau. Sự phân tách này đạt được thông qua việc giới hạn sự giao tiếp: mỗi tầng chỉ được phép giao tiếp với tầng liền kề nó.
Mô hình N-tầng phổ biến nhất là Kiến trúc 3-tầng (3-tier architecture).
Kiến trúc 3-tầng
Kiến trúc 3-tầng là một mô hình kiến trúc phần mềm phổ biến. Nó được thiết kế để phân chia ứng dụng thành ba đơn vị logic và vật lý riêng biệt, giúp tăng tính linh hoạt, khả năng mở rộng, và bảo mật.
Kiến trúc 3-tầng được hình thành bằng cách tách ba chức năng chính của ứng dụng thành các tầng (tier) độc lập, thường chạy trên các máy chủ vật lý hoặc logic khác nhau. 
Ba tầng đó là: 
- Trình bày (presentation)
- Logic nghiệp vụ (business logic)
- Dữ liệu (data)
Xem hình minh họa:
 
Cụ thể hơn:
Tên lớp (tier)	Vai trò chính	Nhiệm vụ	Ví dụ công nghệ
Trình bày
(Presentation)	Giao diện người dùng	Xử lý việc hiển thị thông tin, nhận yêu cầu từ người dùng (nhập liệu, bấm chuột) và chuyển tiếp các yêu cầu xuống tầng Logic nghiệp vụ.	Frontend framework (React, Angular, Vue),
HTML/CSS, Ứng dụng di động
Logic nghiệp vụ
(Business logic/Application)	Logic cốt lõi	Chứa các quy tắc nghiệp vụ, logic xử lý dữ liệu và điều phối các tác vụ. Đây là “bộ não” của ứng dụng, nơi xử lý các yêu cầu từ tầng Trình bày trước khi tương tác với dữ liệu.	Backend framework (Spring Boot, .NET Core, Node.js/Express), REST APIs
Dữ liệu 
(Data)	Lưu trữ và quản lý dữ liệu	Chứa cơ sở dữ liệu (database management system - DBMS), lưu trữ, quản lý, truy xuất và đảm bảo tính toàn vẹn của dữ liệu	Cơ sở dữ liệu (SQL Server, PostgreSQL, MongoDB), Hệ thống lưu trữ tập tin
Ưu điểm:
- Khả năng tái sử dụng: Logic nghiệp vụ nằm ở tầng giữa, độc lập với tầng trình bày. Vì vậy, một logic nghiệp vụ có thể được sử dụng bởi nhiều giao diện khác nhau. Ví dụ: một API xử lý thanh toán có thể được gọi từ cả ứng dụng web và ứng dụng di động
- Khả năng mở rộng: Đây là ưu điểm lớn nhất so với kiến trúc nguyên khối. Bạn có thể mở rộng độc lập theo từng tầng. Ví dụ: thêm máy chủ cho tầng Logic nghiệp vụ khi có nhiều yêu cầu API hơn, mà không cần thêm máy chủ cho tầng Dữ liệu
-  Có tính bảo mật cao: Tầng Dữ liệu được cô lập, chỉ giao tiếp với tầng Logic nghiệp vụ, mà không giao tiếp với người dùng cuối. Điều này giúp bảo vệ cơ sở dữ liệu khỏi các truy cập trái phép từ bên ngoài
- Dễ phát triển và bảo trì: Vì mỗi tầng có trách nhiệm rõ ràng, các lập trình viên có thể tập trung vào một tầng cụ thể mà không làm ảnh hưởng đến các tầng khác. Đội Frontend có thể làm việc song song với đội Backend, chỉ cần tuân thủ giao diện API
Nhược điểm:
- Phức tạp: Việc thiết lập và quản lý kiến trúc phân tán nhiều tầng phức tạp hơn so với kiến trúc nguyên khối
- Độ trễ: Việc truyền dữ liệu qua nhiều tầng (qua mạng) có thể làm tăng độ trễ (latency) so với việc gọi hàm cục bộ
- Chi phí: Việc duy trì nhiều máy chủ/dịch vụ vật lý hoặc máy ảo cho mỗi tầng sẽ tốn kém hơn
Khi nào thì nên sử dụng kiến trúc 3-tầng:
- Khi ứng dụng của bạn phức tạp, dự kiến phát triển lớn trong tương lai, cần khả năng mở rộng cao và bảo mật dữ liệu được ưu tiên
5.5 Kiến trúc vi dịch vụ
Kiến trúc vi dịch vụ (microservices) là một phương pháp thiết kế phần mềm, trong đó một ứng dụng lớn được chia thành một tập hợp các dịch vụ nhỏ, độc lập. Nó là một kiến trúc phần mềm phân tán.
Một số đặc điểm:
- Tính độc lập: Mỗi dịch vụ (service) chạy trong tiến trình (process) riêng biệt của nó
- Chức năng chuyên biệt: Mỗi dịch vụ tập trung vào việc thực hiện một chức năng nghiệp vụ cụ thể (ví dụ: dịch vụ quản lý người dùng, dịch vụ xử lý thanh toán, dịch vụ kho hàng)
- Giao tiếp: Các dịch vụ giao tiếp với nhau qua mạng bằng các giao thức nhẹ, phổ biến nhất là RESTful API hoặc message broker (hàng đợi tin nhắn)
- Công nghệ đa dạng (polyglot): Các dịch vụ khác nhau có thể được xây dựng bằng các ngôn ngữ lập trình, framework và thậm chí là cơ sở dữ liệu riêng (independent database) phù hợp nhất với yêu cầu của dịch vụ đó
Mô hình này trái ngược hoàn toàn với kiến trúc nguyên khối (monolithic), nơi mọi thứ được đóng gói thành một đơn vị duy nhất.
Xem hình minh họa.
 


Ưu điểm:
- Khả năng mở rộng độc lập: Có thể mở rộng từng dịch vụ riêng biệt dựa trên nhu cầu tải thực tế, giúp tối ưu hóa tài nguyên (ví dụ: chỉ cần thêm server cho dịch vụ giỏ hàng mà không cần thêm server cho dịch vụ tài khoản)
- Linh hoạt công nghệ: Cho phép các nhóm sử dụng công nghệ (tech stack) tốt nhất cho từng dịch vụ cụ thể (polyglot programming)
- Dễ dàng bảo trì và phát triển: Mã nguồn của mỗi dịch vụ nhỏ và dễ hiểu hơn. Các nhóm phát triển có thể làm việc, triển khai và cập nhật dịch vụ của họ độc lập với các dịch vụ khác (decoupling)
- Khả năng chịu lỗi cao: Nếu một dịch vụ bị lỗi, các dịch vụ khác vẫn có thể tiếp tục hoạt động (fault isolation). Hệ thống không bị sập toàn bộ như trong monolithic
- Triển khai liên tục (CI/CD): Dễ dàng áp dụng DevOps và CI/CD vì chỉ cần triển khai lại các dịch vụ nhỏ đã thay đổi, không cần triển khai toàn bộ ứng dụng lớn
Nhược điểm:
- Phức tạp về vận hành: Việc quản lý, giám sát (monitoring) và gỡ lỗi (debugging) một hệ thống gồm hàng chục hoặc hàng trăm dịch vụ phân tán phức tạp hơn nhiều
- Độ trễ mạng (latency): Các dịch vụ giao tiếp qua mạng (API call) thay vì gọi hàm cục bộ, dẫn đến độ trễ cao hơn so với monolithic
- Quản lý dữ liệu phân tán: Xử lý giao dịch trải dài qua nhiều cơ sở dữ liệu (distributed transactions) rất phức tạp và cần các mẫu thiết kế như Saga
- Chi phí cơ sở hạ tầng: Cần nhiều tài nguyên hơn cho việc chạy nhiều tiến trình, nhiều cơ sở dữ liệu và các công cụ quản lý phức tạp (kubernetes, service mesh, API gateway)
- Kiểm thử tích hợp: Việc đảm bảo tất cả các dịch vụ phối hợp nhịp nhàng với nhau khó khăn hơn so với kiểm thử end-to-end trong monolithic
Khi nào thì nên sử dụng mô hình microservices:
Microservices không phải là giải pháp cho mọi vấn đề. Nó đặc biệt phù hợp khi dự án đạt đến một mức độ phức tạp và quy mô nhất định:
- Hệ thống phức tạp và quy mô lớn: Khi ứng dụng có nhiều chức năng nghiệp vụ riêng biệt và mã nguồn (codebase) trở nên quá cồng kềnh
- Yêu cầu khả năng mở rộng cao và độc lập: Khi một số chức năng (ví dụ: tìm kiếm, streaming) có nhu cầu tải (load) cao hơn nhiều so với các chức năng khác
- Tổ chức lớn với nhiều đội (team autonomy): Khi các nhóm khác nhau có thể sở hữu, phát triển và triển khai dịch vụ của riêng họ mà không bị phụ thuộc vào nhau
- Cần triển khai nhanh chóng và thường xuyên: Khi yêu cầu cập nhật, thêm tính năng mới liên tục và cần thời gian ngưng hệ thống (downtime) tối thiểu
- Có kinh nghiệm vận hành (DevOps maturity): Đội ngũ phát triển đã có kinh nghiệm với các công cụ như Docker, Kubernetes, CI/CD, và các hệ thống giám sát phân tán
Phân tích và thiết kế PM (7) - Nguyên tắc thiết kế
Bài trước: Phân tích và thiết kế PM (6) - Kiến trúc phần mềm (bài tập)
-----
6. Nguyên tắc thiết kế
6.1 Nguyên tắc SOLID
Nguyên tắc SOLID là một bộ năm nguyên tắc thiết kế hướng đối tượng (OOP) do Robert C. Martin (Bob Martin) và Michael Feathers giới thiệu, nhằm giúp các lập trình viên xây dựng hệ thống phần mềm dễ đọc, dễ hiểu, dễ kiểm tra, dễ bảo trì và mở rộng.
 


SOLID là từ viết tắt của 5 nguyên tắc sau:
Chữ cái	Nguyên tắc (tiếng Anh)	Nguyên tắc (tiếng Việt)	Nội dung tóm tắt
S	Single Responsibility Principle (SRP)	Nguyên tắc Trách nhiệm duy nhất	Một lớp (class) hoặc mô-đun (module) chỉ nên có một lý do duy nhất để thay đổi. (Tức là chỉ chịu trách nhiệm cho một công việc cụ thể)
O	Open/Closed Principle (OCP)	Nguyên tắc Mở/Đóng	Một thực thể (class, module, function) nên mở để mở rộng, nhưng đóng để sửa đổi. (Thêm chức năng mới mà không cần thay đổi mã nguồn hiện có)
L	Liskov Substitution Principle (LSP)	Nguyên tắc Thay thế Liskov	Các đối tượng của lớp con có thể thay thế cho các đối tượng của lớp cha mà không làm thay đổi tính đúng đắn của chương trình
I	Interface Segregation Principle (ISP)	Nguyên tắc Phân tách giao diện	Thay vì sử dụng một giao diện (interface) lớn, cồng kềnh, nên tách nó thành nhiều giao diện nhỏ hơn, cụ thể hơn
D	Dependency Inversion Principle (DIP)	Nguyên tắc Đảo ngược phụ thuộc	Các module cấp cao không nên phụ thuộc vào các module cấp thấp. Cả hai nên phụ thuộc vào Abstraction (trừu tượng hóa - Interface/Abstract Class)
6.2 Áp dụng nguyên tắc SOLID
Để dễ hiểu và có thêm trải nghiệm với nguyên tắc SOLID, chúng ta cùng áp dụng nguyên tắc này vào việc thiết kế Hệ thống bán sách trực tuyến.
Thiết kế theo nguyên tắc SOLID sẽ giúp Hệ thống bán sách trực tuyến có mã nguồn sạch (clean code), dễ bảo trì; đặc biệt để đáp ứng các Yêu cầu phi chức năng (NFR) như khả năng mở rộng (NFR-5.2) và độ tin cậy (NFR-4.1).
Dưới đây là ví dụ về cách áp dụng từng nguyên tắc của SOLID vào Hệ thống bán sách trực tuyến.
[1] S: Single Responsibility Principle (SRP) - Nguyên tắc trách nhiệm duy nhất
Nội dung: Một lớp (class) hoặc module chỉ nên có một lý do để thay đổi, nghĩa là nó chỉ nên có một trách nhiệm duy nhất.
Minh họa trong Hệ thống bán sách trực tuyến:
- Không nên: Có một lớp OrderProcessor vừa xử lý logic đặt hàng, vừa gửi email xác nhận, và vừa cập nhật tồn kho. Nếu logic gửi email thay đổi, lớp này cũng phải thay đổi, vi phạm SRP
- Nên áp dụng: Chia thành các dịch vụ/lớp riêng biệt:
  + OrderService (Dịch vụ Đặt hàng): Chỉ xử lý logic tạo, lưu trữ và theo dõi trạng thái đơn hàng (FR-3.5)
  + InventoryService (Dịch vụ Tồn kho): Chỉ xử lý logic kiểm tra và trừ/cộng số lượng tồn kho (Yêu cầu nghiệp vụ)
  + NotificationService (Dịch vụ Thông báo): Chỉ chịu trách nhiệm gửi email xác nhận hoặc các thông báo khác (FR-3.5)
[2] O: Open/Closed Principle (OCP) - Nguyên tắc mở/đóng
Nội dung: Một thực thể (class, module, function) nên mở để mở rộng nhưng đóng để sửa đổi
Minh họa trong Hệ thống bán sách trực tuyến:
- Bài toán: Hệ thống cần hỗ trợ nhiều phương thức thanh toán (FR-3.4: Thanh toán trực tuyến). Ban đầu chỉ có thanh toán bằng Thẻ tín dụng, sau này cần thêm Ví điện tử
- Không nên: Sửa đổi lớp PaymentProcessor hiện tại, mỗi khi thêm một phương thức thanh toán mới
- Nên áp dụng:
  + Tạo một Interface chung là IPaymentGateway với phương thức processPayment()
  + Mỗi phương thức thanh toán mới (như CreditCardGateway và EWalletGateway) sẽ kế thừa (mở rộng) Interface này
  + Lớp OrderService sử dụng Interface IPaymentGateway mà không cần biết triển khai cụ thể. Khi thêm Ví điện tử, ta chỉ cần thêm lớp mới mà không cần sửa đổi OrderService
[3] L: Liskov Substitution Principle (LSP) - Nguyên tắc thay thế Liskov
Nội dung: Các đối tượng của một lớp con (subclass) có thể thay thế cho các đối tượng của lớp cha (parent class) mà không làm thay đổi tính đúng đắn của chương trình
Minh họa trong Hệ thống bán sách trực tuyến:
- Bài toán: Xử lý các loại sách khác nhau
- Nên áp dụng:
  + Tạo lớp cha trừu tượng (Abstract Class) Book với các thuộc tính chung (title, author, price - FR-2.3)
  + Tạo các lớp con như EBook và PaperbackBook
  + Lớp EBook không được làm những việc mà PaperbackBook làm (ví dụ: tính phí vận chuyển - do ebook không vận chuyển). Nếu hệ thống gọi hàm calculateShippingCost() trên một đối tượng EBook và nó trả về lỗi hoặc một giá trị không hợp lệ, thì đó là vi phạm LSP
  + Để tuân thủ, nên tách logic đặc thù (như vận chuyển) ra khỏi lớp Book chung, hoặc đảm bảo rằng tất cả các sách đều có thể được xử lý (ví dụ, EBook trả về phí vận chuyển bằng 0)
[4] I: Interface Segregation Principle (ISP) - Nguyên tắc phân tách giao diện
Nội dung: Không nên bắt người dùng (lớp) phải phụ thuộc vào các giao diện (interface) mà họ không sử dụng. Thay vì một Interface lớn, nên có nhiều Interface nhỏ, chuyên biệt
Minh họa trong Hệ thống bán sách trực tuyến:
- Không nên: Tạo một Interface IUserRepository chứa mọi phương thức: createUser(), updateProfile(), getHistory(), manageInventory(), sendEmail()
- Nên áp dụng: Phân tách Interface theo trách nhiệm:
  + ICustomerProfileManager: Chỉ có updateProfile(), getHistory() (FR-1.4, FR-1.5)
  + IAdminInventoryManager: Chỉ có manageInventory()
  + Dịch vụ User & Auth Service (quản lý thông tin người dùng) chỉ cần triển khai ICustomerProfileManager, trong khi dịch vụ quản lý backend cần triển khai IAdminInventoryManager
[5] D: Dependency Inversion Principle (DIP) - Nguyên tắc đảo ngược sự phụ thuộc
Nội dung:
- Các module cấp cao (high-level) không nên phụ thuộc vào các module cấp thấp (low-level). Cả hai nên phụ thuộc vào các abstraction (trừu tượng hóa, ví dụ: Interface)
- Abstraction không nên phụ thuộc vào chi tiết (detail); chi tiết nên phụ thuộc vào abstraction
Minh họa trong Hệ thống bán sách trực tuyến:
- Không nên: Lớp OrderService tạo trực tiếp một đối tượng cụ thể là PostgreSQLDatabase để lưu đơn hàng. (Sự phụ thuộc trực tiếp vào chi tiết cấp thấp).
- Nên áp dụng:
  + Tạo một Interface (Abstraction) là IOrderRepository
  + Lớp cấp thấp PostgreSQLOrderRepository sẽ triển khai IOrderRepository
  + OrderService (module cấp cao) sẽ nhận IOrderRepository thông qua Dependency Injection (DI) trong constructor
  + Điều này giúp OrderService không quan tâm đến loại cơ sở dữ liệu đang dùng, có thể dễ dàng chuyển sang dùng MongoDbOrderRepository mà không cần thay đổi mã nguồn của OrderService, đảm bảo tính linh hoạt và khả năng mở rộng (NFR-5.2)

